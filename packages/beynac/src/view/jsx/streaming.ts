/**
 * @module
 * This module enables JSX to supports streaming Response.
 */

import { raw } from "../helper/html";
import type { FC, Context as JSXContext, PropsWithChildren } from "./";
import { childrenToString } from "./components";
import { createContext } from "./context";

/**
 * Used to specify nonce for scripts generated by `Suspense` and `ErrorBoundary`.
 *
 * @example
 * ```tsx
 * <StreamingContext.Provider value={{ scriptNonce: 'test-nonce' }}>
 *   <Suspense fallback={<p>Loading...</p>}>
 *     <Content />
 *   </Suspense>
 * </StreamingContext.Provider>
 * ```
 */
export const StreamingContext: JSXContext<{ scriptNonce: string } | null> =
	createContext<{
		scriptNonce: string;
	} | null>(null);

/**
 * @experimental
 * `Suspense` is an experimental feature.
 * The API might be changed.
 */
// biome-ignore lint/suspicious/noExplicitAny: vendored code
export const Suspense: FC<PropsWithChildren<{ fallback: any }>> = async ({
	children,
	fallback,
}) => {
	if (!children) {
		return fallback?.toString() || "";
	}
	if (!Array.isArray(children)) {
		children = [children];
	}

	try {
		const resArray = await childrenToString(children);
		return raw(resArray.join(""));
	} catch (e) {
		// For SSR, if there's an error or promise, just render children
		// In a real async scenario, the promise would be awaited at the top level
		if (e instanceof Promise) {
			await e;
			const resArray = await childrenToString(children);
			return raw(resArray.join(""));
		}
		throw e;
	}
};
